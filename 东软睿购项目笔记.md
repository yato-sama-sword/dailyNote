# 环境配置步骤

## docker配置

所有环境配置都通过docker进行安装

>一些注意事项
>
>1. rabbitmq需要设置用户和密码才能访问
>2. elk中需要安装ik分词器，可以通过docker映射或者说链接到外部文件夹，实现对容器内配置的更改
>3. fastfdfs要从浏览器访问需要实现nginx代理



# 后端开发思路流程

## 整体框架

项目采用微服务

## 模块设计

### 1.2.1 网关微服务

> 架构图

![img](https://img-blog.csdnimg.cn/20181214102311483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5ajIwMThneXE=,size_16,color_FFFFFF,t_70)

不管是来自于客户端（PC或移动端）的请求，还是服务内部调用。一切对服务的请求都会经过Zuul这个网关，然后再由网关来实现 鉴权、动态路由等等操作。Zuul就是我们服务的统一入口。

> 配置

服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，它还具备了权限控制等功能。为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。

> 主要功能

身份认证与安全：识别每个资源的验证要求，并拒绝那些与要求不相符的请求。（对jwt鉴权）

动态路由：动态地将请求路由到不同的后端集群。

负载均衡和熔断

### 1.2.2 授权中心微服务

> 结合RSA的鉴权

![img](https://img-blog.csdnimg.cn/20181214104033784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5ajIwMThneXE=,size_16,color_FFFFFF,t_70)

- 首先利用RSA生成公钥和私钥。私钥保存在授权中心，公钥保存在Zuul和各个微服务
- 用户请求登录
- 授权中心校验，通过后用私钥对JWT进行签名加密
- 返回jwt给用户
- 用户携带JWT访问
- Zuul直接通过公钥解密JWT，进行验证，验证通过则放行
- 请求到达微服务，微服务直接用公钥解析JWT，获取用户信息，无需访问授权中心

> 授权中心的主要职责

1. 用户鉴权：接收用户的登录请求，通过用户中心的接口进行校验，通过后生成JWT。使用私钥生成JWT并返回
2. 服务鉴权：微服务间的调用不经过Zuul，会有风险，需要鉴权中心进行认证。原理与用户鉴权类似，但逻辑稍微复杂一些（未实现）

### 1.2.3 购物车微服务

>购物车功能

- 用户可以在登录状态下将商品添加到购物车（放入redis）
- 用户可以在未登录状态下将商品添加到购物车（放入localstorage）
- 用户可以使用购物车一起结算下单
- 用户可以查询自己的购物车
- 用户可以在购物车中修改购买商品的数量
- 用户可以在购物车中删除商品
- 在购物车中展示商品优惠信息
- 提示购物车商品价格变化

> **逻辑判断**

新增商品：

​	判断是否登录   

​		是：则添加商品到后台Redis中

​		否：则添加商品到本地的Localstorage

查询购物车

​	判断是否登录

​		否：直接查询localstorage中数据并展示

​		是：已登录，则需要先看本地是否有数据，

​			有：需要提交到后台添加到redis，合并数据，而后查询

​			否：直接去后台查询redis，而后返回





### 1.2.4 评论微服务

> 功能需求

用户在确认收货后可以对商品进行评价，每个用户对订单中的商品只能发布一次顶级评论，可以追评，也可以回复别人的评论。
当用户确认收货后没有进行手动评价时，3天后自动五星好评
表结构设计

parent和isparent字段是用来实现评论嵌套的。

> 实现

使用MongoDB存储评论，基本的CRUD。

### 1.2.5 配置中心微服务

在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。

使用SpringCloudBus来实现配置的自动更新。

> 组成结构

在spring cloud config 组件中，分两个角色，一是config server，二是config client。

Config Server是一个可横向扩展、集中式的配置服务器，它用于集中管理应用程序各个环境下的配置，默认使用Git存储配置文件内容，也可以使用SVN存储，或者是本地文件存存储

Config Client是Config Server的客户端，用于操作存储在Config Server中的配置内容。微服务在启动时会请求Config Server获取配置文件的内容，请求到后再启动容器

> 实现

创建配置中心，对Config Server进行配置，然后在其它微服务中配置Config Client。最后使用Github上的Webhooks进行配置的动态刷新，所以还要使用内网穿透工具，同时要在配置中心中添加过滤器，因为使用Webhooks提交请求时会加上一段Payload，而本地是无法解析这个Payload的，所以要将它过滤掉。

### 1.2.6 页面详情微服务

商品详情浏览量比较大，并发高，所以单独开启一个微服务用来展示商品详情，并且对其进行静态化处理，保存为静态html文件。在用户访问商品详情页面时，让nginx对商品请求进行监听，指向本地静态页面，如果本地没找到，才反向代理到页面详情微服务端口。

### 1.2.7 后台管理微服务

主要是对商品分类、品牌、商品的规格参数以及商品的CRUD，为后台管理提供各种接口。

### 1.2.8 订单微服务

- 创建订单
- 查询订单
- 更新订单状态
- 根据订单号生成微信付款链接
- 根据订单号查询支付状态

### 1.2.9 Eureak注册中心

> 基本架构

![img](https://img-blog.csdnimg.cn/2018121514422783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5ajIwMThneXE=,size_16,color_FFFFFF,t_70)

Eureka：就是服务注册中心（可以是一个集群），对外暴露自己的地址

- 提供者：启动后向Eureka注册自己信息（地址，提供什么服务）

- 消费者：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新

- 心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态

### 1.2.10 搜索微服务

主要是对Elasticsearch的应用，将所有商品数据封装好后添加到Elasticsearch的索引库中，然后进行搜索过滤，查询相应的商品信息。相关知识点留在学习笔记里

### 1.2.11 秒杀微服务

- 添加参加秒杀的商品
- 查询秒杀商品
- 创建秒杀地址
- 验证秒杀地址
- 秒杀

> 秒杀的实现及其优化：
>
> 前端：秒杀地址的隐藏、使用图形验证码
>
> 后端：接口限流，使用消息队列，调用订单微服务执行下单操作。

### 1.2.12 短信微服务

因为系统中不止注册一个地方需要短信发送，因此将短信发送抽取为微服务：leyou-sms-service，凡是需要的地方都可以使用。另外，因为短信发送API调用时长的不确定性，为了提高程序的响应速度，短信发送我们都将采用异步发送方式，即：短信服务监听MQ消息，收到消息后发送短信。其它服务要发送短信时，通过MQ通知短信微服务。

### 1.2.13 文件上传微服务

使用分布式文件系统FastDFS实现图片上传。

FastDFS两个主要的角色：Tracker Server 和 Storage Server 。

Tracker Server：跟踪服务器，主要负责调度storage节点与client通信，在访问上起负载均衡的作用，和记录storage节点的运行状态，是连接client和storage节点的枢纽。

Storage Server：存储服务器，保存文件和文件的meta data（元数据），每个storage server会启动一个单独的线程主动向Tracker cluster中每个tracker server报告其状态信息，包括磁盘使用情况，文件同步情况及文件上传下载次数统计等信息
Group：文件组，多台Storage Server的集群。上传一个文件到同组内的一台机器上后，FastDFS会将该文件即时同步到同组内的其它所有机器上，起到备份的作用。不同组的服务器，保存的数据不同，而且相互独立，不进行通信。

Tracker Cluster：跟踪服务器的集群，有一组Tracker Server（跟踪服务器）组成。

Storage Cluster ：存储集群，有多个Group组成。

> 上传流程

Client通过Tracker server查找可用的Storage server。

Tracker server向Client返回一台可用的Storage server的IP地址和端口号。

Client直接通过Tracker server返回的IP地址和端口与其中一台Storage server建立连接并进行文件上传。

上传完成，Storage server返回Client一个文件ID，文件上传结束。

> 下载流程

Client通过Tracker server查找要下载文件所在的的Storage server。

Tracker server向Client返回包含指定文件的某个Storage server的IP地址和端口号。

Client直接通过Tracker server返回的IP地址和端口与其中一台Storage server建立连接并指定要下载文件。

下载文件成功。

### 1.2.14 用户中心微服务

> 主要功能

- 检查用户名和手机号是否可用
- 发送短信验证码
- 用户注册
- 用户查询
- 修改用户个人资料

## 核心业务

### 基础框架或通用逻辑介绍

>基础功能大多在common服务实现，其他内容也大同小异，所以介绍common服务中的主要内容

1. mapper层：使用mybatis通用mapper实现（tk.mybatis），项目在common服务中封装BaseMapper接口继承Mapper和IdListMapper，让具体业务mapper来实现这个BaseMapper
2. vo层、enums层、exception层、advice层：实现ExceptionResult返回运行时异常数据，并且交由CommonExceptionHandler进一步处理，这里就联系到定义好的异常枚举和异常封装类，可以通过其进行包装给前端返回json数据。实现PageResult返回页面相关数据
3. utils层：实现CookieUtils，可以得到cookie的值和域名，并且对对应的值进行设置；idwork后续单独介绍；jsonUtils实现对json的序列化、转换成bean或list或map等类的解析，当然也可以原生读取；
4. dto层：这一层封装的是给feign的client调用的数据嘞

### tk.mybatis:通用mapper使用

>为什么要用通用mapper

先讲mybatis，通常来说是通过xml文件实现Sql语句，仅仅是简单的增删改查，也需要写大量的代码，而且都是比较重复的。通用mapper在MBG的基础上结合了部分JPA注解，可以简单获取基础单表方法（增删改查），但是多表查询是需要自己写的。

这里又要提一嘴Mybatis Generator了，其通过xml文件配置生成数据库表对应的PO、DAO、XML等文件。但是如果数据库字段变化，就需要重新生成代码，而且MBG覆盖生成代码和追加方式生成XML，导致重新生成时会产生大量的对比修改。

>如何使用通用mapper

1. 在自己创建的mapper接口中继承tk.mybatis.mapper.common.Mapper接口，即可调用全部功能，接口的实现通过动态代理完成。比如下方UserMapper继承Mapper接口后，即可在UserServiceImpl中调用selectCount方法

	```java
	import com.leyou.user.pojo.User;
	import tk.mybatis.mapper.common.Mapper;
	
	public interface UserMapper extends Mapper<User> {
	}
	```

	```java
	public Boolean checkData(String data, Integer type) {
	    User user = new User();
	    switch (type){
	        case 1 :
	            user.setUsername(data);
	            break;
	        case 2 :
	            user.setPhone(data);
	            break;
	        default:
	            return null;
	    }
	    return this.userMapper.selectCount(user) == 0;
	}
	```

2. BaseMapper包含了增删改查方法的基本操作

	```java
	@tk.mybatis.mapper.annotation.RegisterMapper
	public interface BaseMapper<T> extends
	        BaseSelectMapper<T>,
	        BaseInsertMapper<T>,
	        BaseUpdateMapper<T>,
	        BaseDeleteMapper<T> {
	
	}
	```

3. IdsMapper和MysqlMapper包含了批量增删改查的基本方法

	```java
	@tk.mybatis.mapper.annotation.RegisterMapper
	public interface IdsMapper<T> extends SelectByIdsMapper<T>, DeleteByIdsMapper<T> {
	
	}
	```

	```java
	@tk.mybatis.mapper.annotation.RegisterMapper
	public interface MySqlMapper<T> extends
	        InsertListMapper<T>,
	        InsertUseGeneratedKeysMapper<T> {
	
	}
	```

4. ExampleMapper是重点，其继承自MBG，可以实现自定义的查询方法。

	```java
	@tk.mybatis.mapper.annotation.RegisterMapper
	public interface ExampleMapper<T> extends
	        SelectByExampleMapper<T>,
	        SelectOneByExampleMapper<T>,
	        SelectCountByExampleMapper<T>,
	        DeleteByExampleMapper<T>,
	        UpdateByExampleMapper<T>,
	        UpdateByExampleSelectiveMapper<T> {
	
	}
	```

	​	在以下mapper所实现的方法中，都需要Example对象作为参数，而Example对象包含了我们各种自定义的查询条件，正相当于sql语句中where的部分。如何设置Example对象呢？

	​	一般来说可以先创建Example对象，再创建Example.criteria对象。可以对criteria灵活设置各种条件，实现各种复杂的功能。比方说下图代码就可以查询出所有id比1大的用户

	```java
	@Autowired
	    UserMapper userMapper;
	
	@Override
	public List<User> findUserIdGreaterThanOne() {
	    // 创建Example实例
	    Example example = new Example(User.class);
	    // 创建criteria实例
	    Example.Criteria criteria = example.createCriteria();
	    criteria.andGreaterThan("id", 1);
	    example.setOrderByClause("id asc");
	    return userMapper.selectByExample(example);
	}
	
	
	```

作为国产的mybatis增强工具，逻辑清晰，注释易懂，看起来也挺简单的，用起来也比较方便，支持一下

### eureka-ribbon-zuul-hytrix实现网关

1. eureka内置了ribbon，如果不对负载均衡策略进行重写，将默认采用轮询。相较于nginx，ribbon是运行在服务消费者端的客户端/进程内负载均衡器，而nginx是独立的，请求需要先进入nginx。在本项目中，包括eureka注册中心在内的所有服务都被注册在Eureka Server中
2. 除去eureka自然也需要zuul、hytrix的配合啦！如eureka内置ribbon，zuul内置了hytrix，如果超过一定时间未连接到服务，会将服务剔除注册中心，zuul提供路由功能，将url和微服务进行映射，尤其是设置的图片上传功能带来的一些跨域问题更需要解决。在zuul网关中设置cors跨域配置，通过继承ZuulFilter实现对白名单或者有权限用户的放行，以及对其它请求的拦截。

**过滤的基本逻辑是**：

1. 获取cookie中的token
2. JWT对token进行校验
3. 通过则放行，未通过则重定向到登录页

### 登陆注册服务授权相关问题

#### JWT

JWT全称json Web Token，是目前最流行的跨域认证解决方案，基本思想与token相同

JWT会生成一个json对象，返回给用户，保存在前端的cookie或者localstorage中，下次访问自动携带该json对象，服务器可以该对象进行用户身份判断，服务器不再需要保存session数据

> **数据结构**

分为三部分，每一部分都是一串很长的字符串，中间用.分隔

- header：头部，存储加密算法
- payload：负载，用来存放用户相关的数据
- signature：签名，header和payload组合到一起，使用加密算法加密后的数据

**header部分是一个json对象组成**，生成jwt的token时会进行BASE64编码，这个不算加密，只是简单的编码

```javascript
{
	"alg": "Hs256"
    "type": "jwt"
}
```

**payload部分也是一个json对象，用来存放实际需要传递的数据。jwt官方规定了7个字段**

- iss：签发人
- exp：过期时间
- sub：主题
- aud：受众
- nbf：生效时间
- jtl：编号

除了官方字段，我们可以自己加入其他字段，比如

```javascript
{
	"username": "admin",
	"age": 21
}
```

这里同样进行base64编码，默认不进行加密，只能存放不太重要或隐私的内容

到这里需要对前两部分进行数字签名

**signature部分就是负责防止数据篡改**

服务器将持有一个加密的秘钥，该秘钥只有服务器知道，并不会返回给用户。然后使用header中指定的算法对数据进行加密。该部分会将payload中的数据，按照header中的加密算法，加上服务器的秘钥，整体进行加密。

> 优点

1. 默认不加密，也可以加密，不容易被客户端篡改
2. 不仅可以用于认证，而且可以用于交换信息

> 缺点

1. 服务器不保存状态，签发令牌不能提前终止，必须等到过期时间
2. 本身包含认证信息，一旦泄露谁都可以使用，所以过期时间不能太长

#### 具体实现

>总的来说就是token生成解析、rsa加解密的过程

1. 登录授权，验证用户账户密码是否真实，并检验token是否生成
2. 将token写入cookie，并指定httpOnly为true，这样可以防止js获取或修改
3. 登录验证，从cookie中获取token信息，并进行解析
4. 如果解析成功刷新token，并更新cookie中token，返回用户信息

有一点需要注意的是zuul可能会去除一些head信息，让cookie无法携带token，可以配置关闭。

### elasticsearch+kibana+ik分词器实现商品搜索



### rabbitMq实现数据同步



### OpenFeign

>在Ribbon和RestTemplate基础上，OpenFeign实现更简单的编写Http客户端，包装服务的调用，简化服务内部调用流程

使用起来很简单，在api接口**@RequestMapping**注解调用服务对应的路径,这个路径会映射到controller类中，方法上的注解则会映射到对应controller下对应的方法中！在client接口**@FeignClient**注解服务提供方的服务名称，（服务名称在eureka注册中心可以看见）在主启动类注解**@EnableFeignClients**让项目可以通过Feign进行服务调用

```java
@RequestMapping("goods")
public interface GoodsApi {
	@GetMapping("/spu/{id}")
    SpuBo queryGoodsById(@PathVariable("id") Long id);
}
```

```java
@FeignClient(value = "item-service")
public interface GoodsClient extends GoodsApi {
}
```

```java
@SpringBootApplication
@EnableDiscoveryClient
@EnableFeignClients
public class LyCartApplication {

    public static void main(String[] args) {
        SpringApplication.run(LyCartApplication.class,args);
    }
}
```

调用就直接使用client

```java
@Override
public void createIndex(Long id) throws IOException {
    SpuBo spuBo = this.goodsClient.queryGoodsById(id);
    //构建商品
    Goods goods = this.buildGoods(spuBo);

    //保存数据到索引库中
    this.goodsRepository.save(goods);
}
```

### WXpay-微信支付



### 阿里云短信服务



### ID生成算法

SnowFlake（雪花算法）：由64bit二进制数字组成，1+41bit-时间戳+10bit-工作机器id+12bit序列号

- **第 0 位**： 符号位（标识正负），始终为 0，没有用，不用管。
- **第 1~41 位** ：一共 41 位，用来表示时间戳，单位是毫秒，可以支撑 2 ^41 毫秒（约 69 年）
- **第 42~52 位** ：一共 10 位，一般来说，前 5 位表示机房 ID，后 5 位表示机器 ID（实际项目中可以根据实际情况调整！在我最近写的项目里，给节点编号为1、1，以此类推的）。这样就可以区分不同集群/机房的节点。
- **第 53~64 位** ：一共 12 位，用来表示序列号。 序列号为自增值，代表单台机器每毫秒能够产生的最大 ID 数(2^12 = 4096),也就是说单台机器每毫秒最多可以生成 4096 个 唯一 ID。

**优点：**生成速度快、生成ID有序递增、比较灵活

**缺点：**如果机器时间不对，和之前一样，可能会产生重复ID（小概率事件）

### Natapp内网穿透

Spring Bus从Git自动获取更新配置需要设置Webhook，而内网网址直接贴上去是无法访问的的，需要借助内网穿透

>内网穿透是什么？为什么需要内网穿透？natapp如何实现内网穿透

1. 内网穿透指让本地服务端口在公网也可以访问
2. 因为ip有限，大部分本地网络使用的是运营商下的局域网，不能让公网访问，而项目中需要github自动向eureka发送通知给Spring Bus所在服务，so 需要进行内网穿透
3. natapp提供内网外网的隧道，即提供一个公网服务器，给用户分配一个公网地址和端口号。这个公网服务器就相当于中间人

### MongoDB实现评论服务



### 页面静态化处理

商品页面可能受到大量访问，但实际上也不是每个用户都需要实时从数据库中获取当前商品信息，一段时间内的“**准实时**”信息完全够用，所以对于商品页面就进行了页面静态化处理。

**其好处在于：**

1. 提高访问速度，大大提高访问效率
2. 安全性能提高，用户无法从页面获取信息
3. 避免一些因服务端原因导致的一些用户使用问题

## 数据库表的设计

首先考虑最核心的两个概念：spu&sku

spu指的是一组具有共同属性的商品集合

sku指的是一个商品集合中因为具体特性不同而细分的产品（比如颜色不同、大小不同抑或一些原因

**随之而来的一个问题：**spu、sku都只能针对一种或一类商品，但是不同的商品是不一样的，需要将一些特有是属性提取出来，通过json格式进行存储，以在一张表内实现存储不同种类商品信息。顺着这个思路来进行数据库表的设计

### spu

SPU表：

```mysql
CREATE TABLE `tb_spu` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'spu id',
  `title` varchar(255) NOT NULL DEFAULT '' COMMENT '标题',
  `sub_title` varchar(255) DEFAULT '' COMMENT '子标题',
  `cid1` bigint(20) NOT NULL COMMENT '1级类目id',
  `cid2` bigint(20) NOT NULL COMMENT '2级类目id',
  `cid3` bigint(20) NOT NULL COMMENT '3级类目id',
  `brand_id` bigint(20) NOT NULL COMMENT '商品所属品牌id',
  `saleable` tinyint(1) NOT NULL DEFAULT '1' COMMENT '是否上架，0下架，1上架',
  `valid` tinyint(1) NOT NULL DEFAULT '1' COMMENT '是否有效，0已删除，1有效',
  `create_time` datetime DEFAULT NULL COMMENT '添加时间',
  `last_update_time` datetime DEFAULT NULL COMMENT '最后修改时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=208 DEFAULT CHARSET=utf8 COMMENT='spu表，该表描述的是一个抽象的商品，比如 iphone8';
```

与我们前面分析的基本类似，但是似乎少了一些字段，比如商品描述。为了不影响主表的查询效率，需要做表的垂直拆分，将SPU的详情放到了另一张表：tb_spu_detail

```mysql
CREATE TABLE `tb_spu_detail` (
  `spu_id` bigint(20) NOT NULL,
  `description` text COMMENT '商品描述信息',
  `specifications` varchar(3000) NOT NULL DEFAULT '' COMMENT '全部规格参数数据',
  `spec_template` varchar(1000) NOT NULL COMMENT '特有规格参数及可选值信息，json格式',
  `packing_list` varchar(1000) DEFAULT '' COMMENT '包装清单',
  `after_service` varchar(1000) DEFAULT '' COMMENT '售后服务',
  PRIMARY KEY (`spu_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

```

需要注意的是这两个字段：specifications和spec_template。前者是详细的完整的对所有属性都进行了存储，并且对特殊属性的每个特殊选项都进行了展示，而后者则是稍微简化了一些，只保留了一些特殊属性及其相关选项

### sku

SKU表：

```mysql
CREATE TABLE `tb_sku` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'sku id',
  `spu_id` bigint(20) NOT NULL COMMENT 'spu id',
  `title` varchar(255) NOT NULL COMMENT '商品标题',
  `images` varchar(1000) DEFAULT '' COMMENT '商品的图片，多个图片以‘,’分割',
  `price` bigint(15) NOT NULL DEFAULT '0' COMMENT '销售价格，单位为分',
  `indexes` varchar(100) COMMENT '特有规格属性在spu属性模板中的对应下标组合',
  `own_spec` varchar(1000) COMMENT 'sku的特有规格参数，json格式，反序列化时应使用linkedHashMap，保证有序',
  `enable` tinyint(1) NOT NULL DEFAULT '1' COMMENT '是否有效，0无效，1有效',
  `create_time` datetime NOT NULL COMMENT '添加时间',
  `last_update_time` datetime NOT NULL COMMENT '最后修改时间',
  PRIMARY KEY (`id`),
  KEY `key_spu_id` (`spu_id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='sku表,该表表示具体的商品实体,如黑色的64GB的iphone 8';
```

这里说下indexes字段，这个是对应了spu表的特有规格，对于每个特殊属性可以做出一些选择，比如0_0_0，表示的是有三个特殊属性，并且都选择了第一个选项。

此外，由于库存字段的写频率较高，而sku的其它字段以读为主，所以单独创建一张库存表（算是一种读写分离）

```mysql
CREATE TABLE `tb_stock` (
  `sku_id` bigint(20) NOT NULL COMMENT '库存对应的商品sku id',
  `seckill_stock` int(9) DEFAULT '0' COMMENT '可秒杀库存',
  `seckill_total` int(9) DEFAULT '0' COMMENT '秒杀总数量',
  `stock` int(9) NOT NULL COMMENT '库存数量',
  PRIMARY KEY (`sku_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='库存表，代表库存，秒杀库存等信息';
```

### 商品相关表

顺着spu和sku发散，spu对应一类商品，所以需要记录多个商品分类，即设置商品分类表(tb_category)，当然商品也有品牌嘛，所以有商品品牌表(tb_order)，当然还有一个中间对应的表(tb_category_brand)

tb_brand表：

```mysql
CREATE TABLE `tb_brand`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '品牌id',
  `name` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '品牌名称',
  `image` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '品牌图片地址',
  `letter` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '品牌的首字母',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 325400 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '品牌表，一个品牌下有多个商品（spu），一对多关系' ROW_FORMAT = Dynamic;
```

tb_category表：

```mysql
CREATE TABLE `tb_category`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '类目id',
  `name` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '类目名称',
  `parent_id` bigint(20) NOT NULL COMMENT '父类目id,顶级类目填0',
  `is_parent` tinyint(1) NOT NULL COMMENT '是否为父节点，0为否，1为是',
  `sort` int(4) NOT NULL COMMENT '排序指数，越小越靠前',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `key_parent_id`(`parent_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1479 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '商品类目表，类目和商品(spu)是一对多关系，类目与品牌是多对多关系' ROW_FORMAT = Dynamic;

```

tb_category_brand表：

```mysql
CREATE TABLE `tb_category_brand`  (
  `category_id` bigint(20) NOT NULL COMMENT '商品类目id',
  `brand_id` bigint(20) NOT NULL COMMENT '品牌id',
  PRIMARY KEY (`category_id`, `brand_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '商品分类和品牌的中间表，两者是多对多关系' ROW_FORMAT = Dynamic;
```

此外，一类商品应该对应一类规格参数模板（SPU保存有规格参数的具体值哦！），所以需要设置商品规格，这里具体拆分成了两张表，主要是为了搜索服务更加方便。第一张表是规格参数表，详细的描述商品规格的参数；第二张表的规格组表，每个商品分类下有多个分类参数组，使用这张表是为了标记某一规格参数模板对应的是哪一类规格参数（或者说哪一组？

spec_param表：

```mysql
CREATE TABLE `tb_spec_param`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `cid` bigint(20) NOT NULL COMMENT '商品分类id',
  `group_id` bigint(20) NOT NULL,
  `name` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '参数名',
  `numeric` tinyint(1) NOT NULL COMMENT '是否是数字类型参数，true或false',
  `unit` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '数字类型参数的单位，非数字类型可以为空',
  `generic` tinyint(1) NOT NULL COMMENT '是否是sku通用属性，true或false',
  `searching` tinyint(1) NOT NULL COMMENT '是否用于搜索过滤，true或false',
  `segments` varchar(1024) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '数值类型参数，如果需要搜索，则添加分段间隔值，如CPU频率间隔：0.5-1.0',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `key_group`(`group_id`) USING BTREE,
  INDEX `key_category`(`cid`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 33 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '规格参数组下的参数名' ROW_FORMAT = Dynamic;
```

spec_group表：

```mysql
CREATE TABLE `tb_spec_group`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `cid` bigint(20) NOT NULL COMMENT '商品分类id，一个分类下有多个规格组',
  `name` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '规格组的名称',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `key_category`(`cid`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 28 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '规格参数的分组表，每个商品分类下有多个规格参数组' ROW_FORMAT = Dynamic;
```

### 订单相关表

这些表比较常规了，订单表、订单细节表、订单状态表，做这些表的拆分的原因是，合在一起一张表太大了

order表：

```mysql
CREATE TABLE `tb_order`  (
  `order_id` bigint(20) NOT NULL COMMENT '订单id',
  `total_pay` bigint(20) NOT NULL COMMENT '总金额，单位为分',
  `actual_pay` bigint(20) NOT NULL COMMENT '实付金额。单位:分。如:20007，表示:200元7分',
  `promotion_ids` varchar(256) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT '',
  `payment_type` tinyint(1) UNSIGNED ZEROFILL NOT NULL COMMENT '支付类型，1、在线支付，2、货到付款',
  `post_fee` bigint(20) NOT NULL COMMENT '邮费。单位:分。如:20007，表示:200元7分',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '订单创建时间',
  `shipping_name` varchar(20) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL COMMENT '物流名称',
  `shipping_code` varchar(20) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL COMMENT '物流单号',
  `user_id` varchar(32) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL COMMENT '用户id',
  `buyer_message` varchar(128) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL COMMENT '买家留言',
  `buyer_nick` varchar(32) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL COMMENT '买家昵称',
  `buyer_rate` tinyint(1) NULL DEFAULT NULL COMMENT '买家是否已经评价,0未评价，1已评价',
  `receiver_state` varchar(128) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT '' COMMENT '收获地址（省）',
  `receiver_city` varchar(256) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT '' COMMENT '收获地址（市）',
  `receiver_district` varchar(256) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT '' COMMENT '收获地址（区/县）',
  `receiver_address` varchar(256) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT '' COMMENT '收获地址（街道、住址等详细地址）',
  `receiver_mobile` varchar(11) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL COMMENT '收货人手机',
  `receiver_zip` varchar(16) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL COMMENT '收货人邮编',
  `receiver` varchar(32) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL COMMENT '收货人',
  `invoice_type` int(1) NULL DEFAULT 0 COMMENT '发票类型(0无发票1普通发票，2电子发票，3增值税发票)',
  `source_type` int(1) NULL DEFAULT 2 COMMENT '订单来源：1:app端，2：pc端，3：M端，4：微信端，5：手机qq端',
  PRIMARY KEY (`order_id`) USING BTREE,
  INDEX `create_time`(`create_time`) USING BTREE,
  INDEX `buyer_nick`(`buyer_nick`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_bin ROW_FORMAT = Dynamic;
```

order_detail表：

```mysql
CREATE TABLE `tb_order_detail`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '订单详情id ',
  `order_id` bigint(20) NOT NULL COMMENT '订单id',
  `sku_id` bigint(20) NOT NULL COMMENT 'sku商品id',
  `num` int(11) NOT NULL COMMENT '购买数量',
  `title` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '商品标题',
  `own_spec` varchar(1024) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '商品动态属性键值集',
  `price` bigint(20) NOT NULL COMMENT '价格,单位：分',
  `image` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '商品图片',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `key_order_id`(`order_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 218 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '订单详情表' ROW_FORMAT = Dynamic;
```

order_status表：

```mysql
CREATE TABLE `tb_order_status`  (
  `order_id` bigint(20) NOT NULL COMMENT '订单id',
  `status` int(1) NULL DEFAULT NULL COMMENT '状态：1、未付款 2、已付款,未发货 3、已发货,未确认 4、交易成功 5、交易关闭 6、已评价',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '订单创建时间',
  `payment_time` datetime(0) NULL DEFAULT NULL COMMENT '付款时间',
  `consign_time` datetime(0) NULL DEFAULT NULL COMMENT '发货时间',
  `end_time` datetime(0) NULL DEFAULT NULL COMMENT '交易完成时间',
  `close_time` datetime(0) NULL DEFAULT NULL COMMENT '交易关闭时间',
  `comment_time` datetime(0) NULL DEFAULT NULL COMMENT '评价时间',
  PRIMARY KEY (`order_id`) USING BTREE,
  INDEX `status`(`status`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '订单状态表' ROW_FORMAT = Dynamic;
```

此外，还需要记录一下支付记录

pay_log表：

```mysql
CREATE TABLE `tb_pay_log`  (
  `order_id` bigint(20) NOT NULL COMMENT '订单号',
  `total_fee` bigint(20) NULL DEFAULT NULL COMMENT '支付金额（分）',
  `user_id` bigint(20) NULL DEFAULT NULL COMMENT '用户ID',
  `transaction_id` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '微信交易号码',
  `status` tinyint(1) NULL DEFAULT NULL COMMENT '交易状态，1 未支付, 2已支付, 3 已退款, 4 支付错误, 5 已关闭',
  `pay_type` tinyint(1) NULL DEFAULT NULL COMMENT '支付方式，1 微信支付, 2 货到付款',
  `bank_type` varchar(16) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '银行类型',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `pay_time` datetime(0) NULL DEFAULT NULL COMMENT '支付时间',
  `closed_time` datetime(0) NULL DEFAULT NULL COMMENT '关闭时间',
  `refund_time` datetime(0) NULL DEFAULT NULL COMMENT '退款时间',
  PRIMARY KEY (`order_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;
```

### 用户表

这张表还是经典的

```mysql
CREATE TABLE `tb_user`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `username` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '用户名',
  `password` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '密码，加密存储',
  `phone` varchar(11) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '注册手机号',
  `created` datetime(0) NOT NULL COMMENT '创建时间',
  `salt` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '密码加密的salt值',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `username`(`username`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 40 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '用户表' ROW_FORMAT = Dynamic;
```

### 秒杀表





## 疑难杂项

### 1.从Git拉取配置看网络的心情



### 2.秒杀系统高并发有待实现